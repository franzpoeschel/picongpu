/* Copyright 2023-2024 Tapish Narwal, Richard Pausch
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/defines.hpp"
#include "picongpu/plugins/binning/binnerPlugin.hpp"
#include "picongpu/plugins/radiation/VectorTypes.hpp"
#include "picongpu/plugins/radiation/calc_amplitude.hpp"
#include "picongpu/plugins/radiation/particle.hpp"

#include <pmacc/algorithms/math/defines/pi.hpp>

namespace picongpu
{
    namespace plugins::binning
    {
        void eSpec(BinningCreator& binningCreator);
        void larmorPower(BinningCreator& binningCreator);

        inline void getBinning(BinningCreator& binningCreator)
        {
            // call electron spectromter (eSpec) defined below
            eSpec(binningCreator);
            larmorPower(binningCreator);
        }

        inline void eSpec(BinningCreator& binningCreator)
        {
            /**
             * axes definitions below:
             */

            // axis 1: energy axis
            auto getEnergy
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                float3_X const mom = particle[momentum_];
                float_X const weighting = particle[weighting_];
                float_X const mass = picongpu::traits::attribute::getMass(weighting, particle);

                // calculate kinetic energy of a single electron in the macro particle
                float_X energy = KinEnergy<>()(mom, mass) / weighting;

                return energy;
            };

            // Define units of axis 1
            std::array<double, numUnits> energyDimension{};
            energyDimension[SIBaseUnits::length] = 2.0;
            energyDimension[SIBaseUnits::mass] = 1.0;
            energyDimension[SIBaseUnits::time] = -2.0;


            // Create Functor Description for axis 1
            auto energyDescription = createFunctorDescription<float_X>(getEnergy, "Energy", energyDimension);

            // Create energy Axis (defined in SI units)
            float_X const minEnergy = 0.0_X;
            float_X const maxEnergy_MeV = 100.0_X;
            float_X const maxEnergy = sim.si.conv().eV2Joule(maxEnergy_MeV * 1e6); // [J]
            auto ax_energy
                = axis::createLinear(axis::AxisSplitting(axis::Range{minEnergy, maxEnergy}, 800), energyDescription);


            // axis 2: pointing axis
            auto getPointingXY
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                auto theta = math::atan2(particle[momentum_][0], particle[momentum_][1]);
                return theta;
            };

            // Define units of axis 2
            std::array<double, numUnits> pointingXYDimension{};
            pointingXYDimension[SIBaseUnits::length] = 0.0;
            pointingXYDimension[SIBaseUnits::mass] = 0.0;
            pointingXYDimension[SIBaseUnits::time] = 0.0;

            // Create Functor Description for axis 2
            auto pointingXYDescription
                = createFunctorDescription<float_X>(getPointingXY, "pointingXY", pointingXYDimension);

            // Create pointing axis Axis
            float_X pointing_range = 250.0e-3;
            auto ax_pointing = axis::createLinear(
                axis::AxisSplitting(axis::Range{-1._X * pointing_range, +1._X * pointing_range}, 256),
                pointingXYDescription);

            // Bring the axes together in a tuple
            auto axisTuple = createTuple(ax_energy, ax_pointing);


            /**
             * Define the species to do binning over here
             * create object from type
             */
            auto electronsObj = PMACC_CSTRING("e"){};

            // Bring the species together in a tuple
            auto speciesTuple = createSpeciesTuple(electronsObj);


            /**
             * Define deposited quantity here: charge per bin
             */
            auto getParticleCharge
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                float_X const charge = picongpu::traits::attribute::getCharge(particle[weighting_], particle);
                return charge;
            };

            std::array<double, numUnits> depositedUnits{};
            depositedUnits[SIBaseUnits::length] = 0.0;
            depositedUnits[SIBaseUnits::electricCurrent] = 1.0;
            depositedUnits[SIBaseUnits::time] = 1.0;

            // The functor return type should be same as createFunctorDescription template type
            auto chargeDepositionData = createFunctorDescription<float_X>(getParticleCharge, "Charge", depositedUnits);


            binningCreator.addParticleBinner("eSpec", axisTuple, speciesTuple, chargeDepositionData)
                .setNotifyPeriod("100")
                .setOpenPMDJsonCfg(R"({"adios2":{"dataset":{"chunks":"auto"}}})")
                .setOpenPMDExtension("bp");
        }

        inline void larmorPower(BinningCreator& binningCreator)
        {
            // axis 3a: x axis
            auto getPositionX
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                auto pos = getParticlePosition<DomainOrigin::TOTAL, PositionPrecision::SUB_CELL, PositionUnits::PIC>(
                    domainInfo,
                    particle);
                return pos.x();
            };

            // axis 3b: y axis
            auto getPositionY
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                auto pos = getParticlePosition<
                    DomainOrigin::MOVING_WINDOW,
                    PositionPrecision::SUB_CELL,
                    PositionUnits::PIC>(domainInfo, particle);
                return pos.y();
            };

            // axis 3c: z axis
            auto getPositionZ
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                auto pos = getParticlePosition<DomainOrigin::TOTAL, PositionPrecision::SUB_CELL, PositionUnits::PIC>(
                    domainInfo,
                    particle);
                return pos.z();
            };

            // Define units of axis 3
            std::array<double, numUnits> positionDimension{};
            positionDimension[SIBaseUnits::length] = 1.0;
            positionDimension[SIBaseUnits::mass] = 0.0;
            positionDimension[SIBaseUnits::time] = 0.0;

            // Create Functor Description for axis 3a
            auto positionXDescription
                = createFunctorDescription<float_X>(getPositionX, "positionX", positionDimension);

            // Create Functor Description for axis 3b
            auto positionYDescription
                = createFunctorDescription<float_X>(getPositionY, "positionY", positionDimension);

            // Create Functor Description for axis 3z
            auto positionZDescription
                = createFunctorDescription<float_X>(getPositionZ, "positionZ", positionDimension);


            // Create position x axis
            auto ax_positionX
                = axis::createLinear(axis::AxisSplitting(axis::Range{0.0_X, 34.0e-6_X}, 256), positionXDescription);

            // Create position y axis
            auto ax_positionY
                = axis::createLinear(axis::AxisSplitting(axis::Range{0.0_X, 90.0e-6_X}, 512), positionYDescription);

            // Create position z axis
            auto ax_positionZ
                = axis::createLinear(axis::AxisSplitting(axis::Range{0.0_X, 34.0e-6_X}, 128), positionZDescription);


            // Bring the axes together in a tuple
            auto axisTuplePos = createTuple(ax_positionX, ax_positionY, ax_positionZ);


            /**
             * Define the species to do binning over here
             * create object from type
             */
            auto electronsObj = PMACC_CSTRING("e"){};

            // Bring the species together in a tuple
            auto speciesTuple = createSpeciesTuple(electronsObj);


            /**
             * Define deposited quantity here: Larmor power per bin
             */
            auto getLarmorPower
                = [] ALPAKA_FN_ACC(auto const& worker, auto const& domainInfo, auto const& particle) -> float_X
            {
                namespace rad = plugins::radiation;

                float_X const charge = picongpu::traits::attribute::getCharge(particle[weighting_], particle);
                rad::vector_64 n = rad::vector_64(0.0, 1.0, 0.0); // observation directon

                rad::vector_64 const particle_locationNow = rad::vector_64(0.0, 0.0, 0.0);

                float_X const weighting = particle[weighting_];

                // mass of macro-particle
                float_X const particle_mass = picongpu::traits::attribute::getMass(weighting, particle);

                rad::vector_X const particle_momentumNow = rad::vector_X(particle[momentum_]);
                rad::vector_X const particle_momentumOld = rad::vector_X(particle[momentumPrev1_]);

                // set up particle using the radiation's own particle class
                rad::Particle const particleRad(
                    particle_locationNow,
                    particle_momentumOld,
                    particle_momentumNow,
                    particle_mass);

                rad::vector_64 const beta(particleRad.getBeta<rad::When::now>()); // beta = v/c
                rad::vector_64 const beta_dot(
                    (beta - particleRad.getBeta<rad::When::now + 1>())
                    / sim.pic.getDt()); // numeric differentiation (backward difference)
                picongpu::float_64 const innerValue = 1.0 / rad::OneMinusBetaTimesN()(n, particleRad);
                picongpu::float_64 const factor
                    = innerValue * innerValue * innerValue * innerValue * innerValue; // x^5
                // factor=1/(1-beta*n)^g   g=2 for DFT and g=3 for FFT
                rad::vector_64 const numerator_vector = (n % ((n - beta) % beta_dot));
                float_X const numerator = numerator_vector * numerator_vector;

                float_X const SI_prefactor
                    = 1.0_X
                      / (16.0_X * pmacc::math::Pi<float_X>::value * pmacc::math::Pi<float_X>::value
                         * picongpu::sim.pic.getEps0() * picongpu::sim.pic.getSpeedOfLight());

                return SI_prefactor * charge * charge * numerator * factor;
            };

            std::array<double, numUnits> depositedUnitsLarmor{};
            depositedUnitsLarmor[SIBaseUnits::length] = 2.0;
            depositedUnitsLarmor[SIBaseUnits::mass] = 1.0;
            depositedUnitsLarmor[SIBaseUnits::time] = -3.0;

            // The functor return type should be same as createFunctorDescription template type
            auto larmorPowerDepositionData
                = createFunctorDescription<float_X>(getLarmorPower, "Larmor power", depositedUnitsLarmor);


            binningCreator.addParticleBinner("larmorPowerDens", axisTuplePos, speciesTuple, larmorPowerDepositionData)
                .setNotifyPeriod("100")
                .setOpenPMDJsonCfg(R"({"adios2":{"dataset":{"chunks":"auto"}}})")
                .setOpenPMDExtension("bp");
        }
    } // namespace plugins::binning
} // namespace picongpu
